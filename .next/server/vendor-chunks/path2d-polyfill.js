"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/path2d-polyfill";
exports.ids = ["vendor-chunks/path2d-polyfill"];
exports.modules = {

/***/ "(rsc)/./node_modules/path2d-polyfill/dist/path2d-node.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/path2d-polyfill/dist/path2d-node.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nvar ARG_LENGTH = {\n    a: 7,\n    c: 6,\n    h: 1,\n    l: 2,\n    m: 2,\n    q: 4,\n    s: 4,\n    t: 2,\n    v: 1,\n    z: 0\n};\nvar SEGMENT_PATTERN = /([astvzqmhlc])([^astvzqmhlc]*)/gi;\nvar NUMBER = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/gi;\nfunction parseValues(args) {\n    var numbers = args.match(NUMBER);\n    return numbers ? numbers.map(Number) : [];\n}\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * https://www.w3.org/TR/SVG/paths.html#PathDataGeneralInformation\n * @ignore\n *\n * @param {string} path\n * @returns {array}\n */\nfunction parsePath(path) {\n    var data = [];\n    var p = String(path).trim();\n    // A path data segment (if there is one) must begin with a \"moveto\" command\n    if (p[0] !== \"M\" && p[0] !== \"m\") {\n        return data;\n    }\n    p.replace(SEGMENT_PATTERN, function (_, command, args) {\n        var theArgs = parseValues(args);\n        var type = command.toLowerCase();\n        var theCommand = command;\n        // overloaded moveTo\n        if (type === \"m\" && theArgs.length > 2) {\n            data.push(__spreadArray([theCommand], theArgs.splice(0, 2), true));\n            type = \"l\";\n            theCommand = theCommand === \"m\" ? \"l\" : \"L\";\n        }\n        // Ignore invalid commands\n        if (theArgs.length < ARG_LENGTH[type]) {\n            return \"\";\n        }\n        data.push(__spreadArray([theCommand], theArgs.splice(0, ARG_LENGTH[type]), true));\n        // The command letter can be eliminated on subsequent commands if the\n        // same command is used multiple times in a row (e.g., you can drop the\n        // second \"L\" in \"M 100 200 L 200 100 L -100 -200\" and use\n        // \"M 100 200 L 200 100 -100 -200\" instead).\n        while (theArgs.length >= ARG_LENGTH[type] && theArgs.length && ARG_LENGTH[type]) {\n            data.push(__spreadArray([theCommand], theArgs.splice(0, ARG_LENGTH[type]), true));\n        }\n        return \"\";\n    });\n    return data;\n}\n\nfunction rotatePoint(point, angle) {\n    var nx = point.x * Math.cos(angle) - point.y * Math.sin(angle);\n    var ny = point.y * Math.cos(angle) + point.x * Math.sin(angle);\n    point.x = nx;\n    point.y = ny;\n}\nfunction translatePoint(point, dx, dy) {\n    point.x += dx;\n    point.y += dy;\n}\nfunction scalePoint(point, s) {\n    point.x *= s;\n    point.y *= s;\n}\n/**\n * Implements a browser's Path2D api\n */\nvar Path2D = /** @class */ (function () {\n    function Path2D(path) {\n        var _a;\n        this.commands = [];\n        if (path && path instanceof Path2D) {\n            (_a = this.commands).push.apply(_a, path.commands);\n        }\n        else if (path) {\n            this.commands = parsePath(path);\n        }\n    }\n    Path2D.prototype.addPath = function (path) {\n        var _a;\n        if (path && path instanceof Path2D) {\n            (_a = this.commands).push.apply(_a, path.commands);\n        }\n    };\n    Path2D.prototype.moveTo = function (x, y) {\n        this.commands.push([\"M\", x, y]);\n    };\n    Path2D.prototype.lineTo = function (x, y) {\n        this.commands.push([\"L\", x, y]);\n    };\n    Path2D.prototype.arc = function (x, y, r, start, end, ccw) {\n        this.commands.push([\"AC\", x, y, r, start, end, !!ccw]);\n    };\n    Path2D.prototype.arcTo = function (x1, y1, x2, y2, r) {\n        this.commands.push([\"AT\", x1, y1, x2, y2, r]);\n    };\n    Path2D.prototype.ellipse = function (x, y, rx, ry, angle, start, end, ccw) {\n        this.commands.push([\"E\", x, y, rx, ry, angle, start, end, !!ccw]);\n    };\n    Path2D.prototype.closePath = function () {\n        this.commands.push([\"Z\"]);\n    };\n    Path2D.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n        this.commands.push([\"C\", cp1x, cp1y, cp2x, cp2y, x, y]);\n    };\n    Path2D.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {\n        this.commands.push([\"Q\", cpx, cpy, x, y]);\n    };\n    Path2D.prototype.rect = function (x, y, width, height) {\n        this.commands.push([\"R\", x, y, width, height]);\n    };\n    Path2D.prototype.roundRect = function (x, y, width, height, radii) {\n        if (typeof radii === \"undefined\") {\n            this.commands.push([\"RR\", x, y, width, height, 0]);\n        }\n        else {\n            this.commands.push([\"RR\", x, y, width, height, radii]);\n        }\n    };\n    return Path2D;\n}());\nfunction buildPath(ctx, commands) {\n    var x = 0;\n    var y = 0;\n    var endAngle;\n    var startAngle;\n    var largeArcFlag;\n    var sweepFlag;\n    var endPoint;\n    var midPoint;\n    var angle;\n    var lambda;\n    var t1;\n    var t2;\n    var x1;\n    var y1;\n    var r;\n    var rx;\n    var ry;\n    var w;\n    var h;\n    var pathType;\n    var centerPoint;\n    var ccw;\n    var radii;\n    var cpx = null;\n    var cpy = null;\n    var qcpx = null;\n    var qcpy = null;\n    var startPoint = null;\n    var currentPoint = null;\n    ctx.beginPath();\n    for (var i = 0; i < commands.length; ++i) {\n        pathType = commands[i][0];\n        // Reset control point if command is not cubic\n        if (pathType !== \"S\" && pathType !== \"s\" && pathType !== \"C\" && pathType !== \"c\") {\n            cpx = null;\n            cpy = null;\n        }\n        if (pathType !== \"T\" && pathType !== \"t\" && pathType !== \"Q\" && pathType !== \"q\") {\n            qcpx = null;\n            qcpy = null;\n        }\n        var c = void 0;\n        switch (pathType) {\n            case \"m\":\n            case \"M\":\n                c = commands[i];\n                if (pathType === \"m\") {\n                    x += c[1];\n                    y += c[2];\n                }\n                else {\n                    x = c[1];\n                    y = c[2];\n                }\n                if (pathType === \"M\" || !startPoint) {\n                    startPoint = { x: x, y: y };\n                }\n                ctx.moveTo(x, y);\n                break;\n            case \"l\":\n                c = commands[i];\n                x += c[1];\n                y += c[2];\n                ctx.lineTo(x, y);\n                break;\n            case \"L\":\n                c = commands[i];\n                x = c[1];\n                y = c[2];\n                ctx.lineTo(x, y);\n                break;\n            case \"H\":\n                c = commands[i];\n                x = c[1];\n                ctx.lineTo(x, y);\n                break;\n            case \"h\":\n                c = commands[i];\n                x += c[1];\n                ctx.lineTo(x, y);\n                break;\n            case \"V\":\n                c = commands[i];\n                y = c[1];\n                ctx.lineTo(x, y);\n                break;\n            case \"v\":\n                c = commands[i];\n                y += c[1];\n                ctx.lineTo(x, y);\n                break;\n            case \"a\":\n            case \"A\":\n                c = commands[i];\n                if (currentPoint === null) {\n                    throw new Error(\"This should never happen\");\n                }\n                if (pathType === \"a\") {\n                    x += c[6];\n                    y += c[7];\n                }\n                else {\n                    x = c[6];\n                    y = c[7];\n                }\n                rx = c[1]; // rx\n                ry = c[2]; // ry\n                angle = (c[3] * Math.PI) / 180;\n                largeArcFlag = !!c[4];\n                sweepFlag = !!c[5];\n                endPoint = { x: x, y: y };\n                // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n                midPoint = {\n                    x: (currentPoint.x - endPoint.x) / 2,\n                    y: (currentPoint.y - endPoint.y) / 2\n                };\n                rotatePoint(midPoint, -angle);\n                // radius correction\n                lambda = (midPoint.x * midPoint.x) / (rx * rx) + (midPoint.y * midPoint.y) / (ry * ry);\n                if (lambda > 1) {\n                    lambda = Math.sqrt(lambda);\n                    rx *= lambda;\n                    ry *= lambda;\n                }\n                centerPoint = {\n                    x: (rx * midPoint.y) / ry,\n                    y: -(ry * midPoint.x) / rx\n                };\n                t1 = rx * rx * ry * ry;\n                t2 = rx * rx * midPoint.y * midPoint.y + ry * ry * midPoint.x * midPoint.x;\n                if (sweepFlag !== largeArcFlag) {\n                    scalePoint(centerPoint, Math.sqrt((t1 - t2) / t2) || 0);\n                }\n                else {\n                    scalePoint(centerPoint, -Math.sqrt((t1 - t2) / t2) || 0);\n                }\n                startAngle = Math.atan2((midPoint.y - centerPoint.y) / ry, (midPoint.x - centerPoint.x) / rx);\n                endAngle = Math.atan2(-(midPoint.y + centerPoint.y) / ry, -(midPoint.x + centerPoint.x) / rx);\n                rotatePoint(centerPoint, angle);\n                translatePoint(centerPoint, (endPoint.x + currentPoint.x) / 2, (endPoint.y + currentPoint.y) / 2);\n                ctx.save();\n                ctx.translate(centerPoint.x, centerPoint.y);\n                ctx.rotate(angle);\n                ctx.scale(rx, ry);\n                ctx.arc(0, 0, 1, startAngle, endAngle, !sweepFlag);\n                ctx.restore();\n                break;\n            case \"C\":\n                c = commands[i];\n                cpx = c[3]; // Last control point\n                cpy = c[4];\n                x = c[5];\n                y = c[6];\n                ctx.bezierCurveTo(c[1], c[2], cpx, cpy, x, y);\n                break;\n            case \"c\":\n                c = commands[i];\n                ctx.bezierCurveTo(c[1] + x, c[2] + y, c[3] + x, c[4] + y, c[5] + x, c[6] + y);\n                cpx = c[3] + x; // Last control point\n                cpy = c[4] + y;\n                x += c[5];\n                y += c[6];\n                break;\n            case \"S\":\n                c = commands[i];\n                if (cpx === null || cpy === null) {\n                    cpx = x;\n                    cpy = y;\n                }\n                ctx.bezierCurveTo(2 * x - cpx, 2 * y - cpy, c[1], c[2], c[3], c[4]);\n                cpx = c[1]; // last control point\n                cpy = c[2];\n                x = c[3];\n                y = c[4];\n                break;\n            case \"s\":\n                c = commands[i];\n                if (cpx === null || cpy === null) {\n                    cpx = x;\n                    cpy = y;\n                }\n                ctx.bezierCurveTo(2 * x - cpx, 2 * y - cpy, c[1] + x, c[2] + y, c[3] + x, c[4] + y);\n                cpx = c[1] + x; // last control point\n                cpy = c[2] + y;\n                x += c[3];\n                y += c[4];\n                break;\n            case \"Q\":\n                c = commands[i];\n                qcpx = c[1]; // last control point\n                qcpy = c[2];\n                x = c[3];\n                y = c[4];\n                ctx.quadraticCurveTo(qcpx, qcpy, x, y);\n                break;\n            case \"q\":\n                c = commands[i];\n                qcpx = c[1] + x; // last control point\n                qcpy = c[2] + y;\n                x += c[3];\n                y += c[4];\n                ctx.quadraticCurveTo(qcpx, qcpy, x, y);\n                break;\n            case \"T\":\n                c = commands[i];\n                if (qcpx === null || qcpy === null) {\n                    qcpx = x;\n                    qcpy = y;\n                }\n                qcpx = 2 * x - qcpx; // last control point\n                qcpy = 2 * y - qcpy;\n                x = c[1];\n                y = c[2];\n                ctx.quadraticCurveTo(qcpx, qcpy, x, y);\n                break;\n            case \"t\":\n                c = commands[i];\n                if (qcpx === null || qcpy === null) {\n                    qcpx = x;\n                    qcpy = y;\n                }\n                qcpx = 2 * x - qcpx; // last control point\n                qcpy = 2 * y - qcpy;\n                x += c[1];\n                y += c[2];\n                ctx.quadraticCurveTo(qcpx, qcpy, x, y);\n                break;\n            case \"z\":\n            case \"Z\":\n                if (startPoint) {\n                    x = startPoint.x;\n                    y = startPoint.y;\n                }\n                startPoint = null;\n                ctx.closePath();\n                break;\n            case \"AC\": // arc\n                c = commands[i];\n                x = c[1];\n                y = c[2];\n                r = c[3];\n                startAngle = c[4];\n                endAngle = c[5];\n                ccw = c[6];\n                ctx.arc(x, y, r, startAngle, endAngle, ccw);\n                break;\n            case \"AT\": // arcTo\n                c = commands[i];\n                x1 = c[1];\n                y1 = c[2];\n                x = c[3];\n                y = c[4];\n                r = c[5];\n                ctx.arcTo(x1, y1, x, y, r);\n                break;\n            case \"E\": // ellipse\n                c = commands[i];\n                x = c[1];\n                y = c[2];\n                rx = c[3];\n                ry = c[4];\n                angle = c[5];\n                startAngle = c[6];\n                endAngle = c[7];\n                ccw = c[8];\n                ctx.save();\n                ctx.translate(x, y);\n                ctx.rotate(angle);\n                ctx.scale(rx, ry);\n                ctx.arc(0, 0, 1, startAngle, endAngle, ccw);\n                ctx.restore();\n                break;\n            case \"R\": // rect\n                c = commands[i];\n                x = c[1];\n                y = c[2];\n                w = c[3];\n                h = c[4];\n                startPoint = { x: x, y: y };\n                ctx.rect(x, y, w, h);\n                break;\n            case \"RR\": // roundedRect\n                c = commands[i];\n                x = c[1];\n                y = c[2];\n                w = c[3];\n                h = c[4];\n                radii = c[5];\n                startPoint = { x: x, y: y };\n                ctx.roundRect(x, y, w, h, radii);\n                break;\n        }\n        if (!currentPoint) {\n            currentPoint = { x: x, y: y };\n        }\n        else {\n            currentPoint.x = x;\n            currentPoint.y = y;\n        }\n    }\n}\n/**\n * Polyfills CanvasRenderingContext2D stroke, fill and isPointInPath so that they support Path2D objects.\n * @param {WindowLike} window - window like object containing a CanvasRenderingContext2D constructor\n */\nfunction polyfillPath2D(window) {\n    if (!window || !window.CanvasRenderingContext2D || window.Path2D)\n        return;\n    var CanvasRenderingContext2D = window.CanvasRenderingContext2D;\n    /* eslint-disable @typescript-eslint/unbound-method */\n    // setting unbound functions here. Make sure this is set in function call later\n    var cFill = CanvasRenderingContext2D.prototype.fill;\n    var cStroke = CanvasRenderingContext2D.prototype.stroke;\n    var cIsPointInPath = CanvasRenderingContext2D.prototype.isPointInPath;\n    /* eslint-enable @typescript-eslint/unbound-method */\n    CanvasRenderingContext2D.prototype.fill = function fill() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args[0] instanceof Path2D) {\n            var path = args[0];\n            var fillRule = args[1] || \"nonzero\";\n            buildPath(this, path.commands);\n            cFill.apply(this, [fillRule]);\n        }\n        else {\n            var fillRule = args[0] || \"nonzero\";\n            return cFill.apply(this, [fillRule]);\n        }\n    };\n    CanvasRenderingContext2D.prototype.stroke = function stroke(path) {\n        if (path) {\n            buildPath(this, path.commands);\n        }\n        cStroke.apply(this);\n    };\n    CanvasRenderingContext2D.prototype.isPointInPath = function isPointInPath() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args[0] instanceof Path2D) {\n            // first argument is a Path2D object\n            var path = args[0];\n            var x = args[1];\n            var y = args[2];\n            var fillRule = args[3] || \"nonzero\";\n            buildPath(this, path.commands);\n            return cIsPointInPath.apply(this, [x, y, fillRule]);\n        }\n        else {\n            return cIsPointInPath.apply(this, args);\n        }\n    };\n    window.Path2D = Path2D;\n}\n\nfunction roundRect(x, y, width, height, radii) {\n    var _this = this;\n    if (radii === void 0) { radii = 0; }\n    if (typeof radii === \"number\") {\n        // eslint-disable-next-line no-param-reassign\n        radii = [radii];\n    }\n    // check for range error\n    if (Array.isArray(radii)) {\n        if (radii.length === 0 || radii.length > 4) {\n            throw new RangeError(\"Failed to execute 'roundRect' on '\".concat(this.constructor.name, \"': \").concat(radii.length, \" radii provided. Between one and four radii are necessary.\"));\n        }\n        radii.forEach(function (v) {\n            if (v < 0) {\n                throw new RangeError(\"Failed to execute 'roundRect' on '\".concat(_this.constructor.name, \"': Radius value \").concat(v, \" is negative.\"));\n            }\n        });\n    }\n    else {\n        return;\n    }\n    if (radii.length === 1 && radii[0] === 0) {\n        return this.rect(x, y, width, height);\n    }\n    // set the corners\n    // tl = top left radius\n    // tr = top right radius\n    // br = bottom right radius\n    // bl = bottom left radius\n    var minRadius = Math.min(width, height) / 2;\n    var tr, br, bl;\n    var tl = (tr = br = bl = Math.min(minRadius, radii[0]));\n    if (radii.length === 2) {\n        tr = bl = Math.min(minRadius, radii[1]);\n    }\n    if (radii.length === 3) {\n        tr = bl = Math.min(minRadius, radii[1]);\n        br = Math.min(minRadius, radii[2]);\n    }\n    if (radii.length === 4) {\n        tr = Math.min(minRadius, radii[1]);\n        br = Math.min(minRadius, radii[2]);\n        bl = Math.min(minRadius, radii[3]);\n    }\n    // begin with closing current path\n    // this.closePath();\n    // let's draw the rounded rectangle\n    this.moveTo(x, y + height - bl);\n    this.arcTo(x, y, x + tl, y, tl);\n    this.arcTo(x + width, y, x + width, y + tr, tr);\n    this.arcTo(x + width, y + height, x + width - br, y + height, br);\n    this.arcTo(x, y + height, x, y + height - bl, bl);\n    // and move to rects control point for further path drawing\n    this.moveTo(x, y);\n}\n/**\n * Polyfills roundRect on CanvasRenderingContext2D and Path2D\n * @param {WindowLike} window - window like object containing both CanvasRenderingContext2D and Path2D constructor\n */\nfunction polyfillRoundRect(window) {\n    if (!window || !window.CanvasRenderingContext2D)\n        return;\n    var CanvasRenderingContext2D = window.CanvasRenderingContext2D, Path2D = window.Path2D;\n    // polyfill unsupported roundRect for e.g. firefox https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/roundRect#browser_compatibility\n    if (CanvasRenderingContext2D && !CanvasRenderingContext2D.prototype.roundRect) {\n        CanvasRenderingContext2D.prototype.roundRect = roundRect;\n    }\n    if (Path2D && !Path2D.prototype.roundRect) {\n        Path2D.prototype.roundRect = roundRect;\n    }\n}\n\nexports.Path2D = Path2D;\nexports.parsePath = parsePath;\nexports.polyfillPath2D = polyfillPath2D;\nexports.polyfillRoundRect = polyfillRoundRect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGF0aDJkLXBvbHlmaWxsL2Rpc3QvcGF0aDJkLW5vZGUuY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9wYXRoMmQtcG9seWZpbGwvZGlzdC9wYXRoMmQtbm9kZS5janM/Mzg5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxuXG52YXIgQVJHX0xFTkdUSCA9IHtcbiAgICBhOiA3LFxuICAgIGM6IDYsXG4gICAgaDogMSxcbiAgICBsOiAyLFxuICAgIG06IDIsXG4gICAgcTogNCxcbiAgICBzOiA0LFxuICAgIHQ6IDIsXG4gICAgdjogMSxcbiAgICB6OiAwXG59O1xudmFyIFNFR01FTlRfUEFUVEVSTiA9IC8oW2FzdHZ6cW1obGNdKShbXmFzdHZ6cW1obGNdKikvZ2k7XG52YXIgTlVNQkVSID0gLy0/WzAtOV0qXFwuP1swLTldKyg/OmVbLStdP1xcZCspPy9naTtcbmZ1bmN0aW9uIHBhcnNlVmFsdWVzKGFyZ3MpIHtcbiAgICB2YXIgbnVtYmVycyA9IGFyZ3MubWF0Y2goTlVNQkVSKTtcbiAgICByZXR1cm4gbnVtYmVycyA/IG51bWJlcnMubWFwKE51bWJlcikgOiBbXTtcbn1cbi8qKlxuICogcGFyc2UgYW4gc3ZnIHBhdGggZGF0YSBzdHJpbmcuIEdlbmVyYXRlcyBhbiBBcnJheVxuICogb2YgY29tbWFuZHMgd2hlcmUgZWFjaCBjb21tYW5kIGlzIGFuIEFycmF5IG9mIHRoZVxuICogZm9ybSBgW2NvbW1hbmQsIGFyZzEsIGFyZzIsIC4uLl1gXG4gKlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhR2VuZXJhbEluZm9ybWF0aW9uXG4gKiBAaWdub3JlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIHZhciBwID0gU3RyaW5nKHBhdGgpLnRyaW0oKTtcbiAgICAvLyBBIHBhdGggZGF0YSBzZWdtZW50IChpZiB0aGVyZSBpcyBvbmUpIG11c3QgYmVnaW4gd2l0aCBhIFwibW92ZXRvXCIgY29tbWFuZFxuICAgIGlmIChwWzBdICE9PSBcIk1cIiAmJiBwWzBdICE9PSBcIm1cIikge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcC5yZXBsYWNlKFNFR01FTlRfUEFUVEVSTiwgZnVuY3Rpb24gKF8sIGNvbW1hbmQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHRoZUFyZ3MgPSBwYXJzZVZhbHVlcyhhcmdzKTtcbiAgICAgICAgdmFyIHR5cGUgPSBjb21tYW5kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciB0aGVDb21tYW5kID0gY29tbWFuZDtcbiAgICAgICAgLy8gb3ZlcmxvYWRlZCBtb3ZlVG9cbiAgICAgICAgaWYgKHR5cGUgPT09IFwibVwiICYmIHRoZUFyZ3MubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgZGF0YS5wdXNoKF9fc3ByZWFkQXJyYXkoW3RoZUNvbW1hbmRdLCB0aGVBcmdzLnNwbGljZSgwLCAyKSwgdHJ1ZSkpO1xuICAgICAgICAgICAgdHlwZSA9IFwibFwiO1xuICAgICAgICAgICAgdGhlQ29tbWFuZCA9IHRoZUNvbW1hbmQgPT09IFwibVwiID8gXCJsXCIgOiBcIkxcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgaW52YWxpZCBjb21tYW5kc1xuICAgICAgICBpZiAodGhlQXJncy5sZW5ndGggPCBBUkdfTEVOR1RIW3R5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnB1c2goX19zcHJlYWRBcnJheShbdGhlQ29tbWFuZF0sIHRoZUFyZ3Muc3BsaWNlKDAsIEFSR19MRU5HVEhbdHlwZV0pLCB0cnVlKSk7XG4gICAgICAgIC8vIFRoZSBjb21tYW5kIGxldHRlciBjYW4gYmUgZWxpbWluYXRlZCBvbiBzdWJzZXF1ZW50IGNvbW1hbmRzIGlmIHRoZVxuICAgICAgICAvLyBzYW1lIGNvbW1hbmQgaXMgdXNlZCBtdWx0aXBsZSB0aW1lcyBpbiBhIHJvdyAoZS5nLiwgeW91IGNhbiBkcm9wIHRoZVxuICAgICAgICAvLyBzZWNvbmQgXCJMXCIgaW4gXCJNIDEwMCAyMDAgTCAyMDAgMTAwIEwgLTEwMCAtMjAwXCIgYW5kIHVzZVxuICAgICAgICAvLyBcIk0gMTAwIDIwMCBMIDIwMCAxMDAgLTEwMCAtMjAwXCIgaW5zdGVhZCkuXG4gICAgICAgIHdoaWxlICh0aGVBcmdzLmxlbmd0aCA+PSBBUkdfTEVOR1RIW3R5cGVdICYmIHRoZUFyZ3MubGVuZ3RoICYmIEFSR19MRU5HVEhbdHlwZV0pIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChfX3NwcmVhZEFycmF5KFt0aGVDb21tYW5kXSwgdGhlQXJncy5zcGxpY2UoMCwgQVJHX0xFTkdUSFt0eXBlXSksIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcm90YXRlUG9pbnQocG9pbnQsIGFuZ2xlKSB7XG4gICAgdmFyIG54ID0gcG9pbnQueCAqIE1hdGguY29zKGFuZ2xlKSAtIHBvaW50LnkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgdmFyIG55ID0gcG9pbnQueSAqIE1hdGguY29zKGFuZ2xlKSArIHBvaW50LnggKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgcG9pbnQueCA9IG54O1xuICAgIHBvaW50LnkgPSBueTtcbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZVBvaW50KHBvaW50LCBkeCwgZHkpIHtcbiAgICBwb2ludC54ICs9IGR4O1xuICAgIHBvaW50LnkgKz0gZHk7XG59XG5mdW5jdGlvbiBzY2FsZVBvaW50KHBvaW50LCBzKSB7XG4gICAgcG9pbnQueCAqPSBzO1xuICAgIHBvaW50LnkgKj0gcztcbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIGJyb3dzZXIncyBQYXRoMkQgYXBpXG4gKi9cbnZhciBQYXRoMkQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGF0aDJEKHBhdGgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgICAgIGlmIChwYXRoICYmIHBhdGggaW5zdGFuY2VvZiBQYXRoMkQpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuY29tbWFuZHMpLnB1c2guYXBwbHkoX2EsIHBhdGguY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZHMgPSBwYXJzZVBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUGF0aDJELnByb3RvdHlwZS5hZGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAocGF0aCAmJiBwYXRoIGluc3RhbmNlb2YgUGF0aDJEKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmNvbW1hbmRzKS5wdXNoLmFwcGx5KF9hLCBwYXRoLmNvbW1hbmRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGF0aDJELnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goW1wiTVwiLCB4LCB5XSk7XG4gICAgfTtcbiAgICBQYXRoMkQucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMucHVzaChbXCJMXCIsIHgsIHldKTtcbiAgICB9O1xuICAgIFBhdGgyRC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24gKHgsIHksIHIsIHN0YXJ0LCBlbmQsIGNjdykge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goW1wiQUNcIiwgeCwgeSwgciwgc3RhcnQsIGVuZCwgISFjY3ddKTtcbiAgICB9O1xuICAgIFBhdGgyRC5wcm90b3R5cGUuYXJjVG8gPSBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHIpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKFtcIkFUXCIsIHgxLCB5MSwgeDIsIHkyLCByXSk7XG4gICAgfTtcbiAgICBQYXRoMkQucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbiAoeCwgeSwgcngsIHJ5LCBhbmdsZSwgc3RhcnQsIGVuZCwgY2N3KSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMucHVzaChbXCJFXCIsIHgsIHksIHJ4LCByeSwgYW5nbGUsIHN0YXJ0LCBlbmQsICEhY2N3XSk7XG4gICAgfTtcbiAgICBQYXRoMkQucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKFtcIlpcIl0pO1xuICAgIH07XG4gICAgUGF0aDJELnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKFtcIkNcIiwgY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeV0pO1xuICAgIH07XG4gICAgUGF0aDJELnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24gKGNweCwgY3B5LCB4LCB5KSB7XG4gICAgICAgIHRoaXMuY29tbWFuZHMucHVzaChbXCJRXCIsIGNweCwgY3B5LCB4LCB5XSk7XG4gICAgfTtcbiAgICBQYXRoMkQucHJvdG90eXBlLnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goW1wiUlwiLCB4LCB5LCB3aWR0aCwgaGVpZ2h0XSk7XG4gICAgfTtcbiAgICBQYXRoMkQucHJvdG90eXBlLnJvdW5kUmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpaSkge1xuICAgICAgICBpZiAodHlwZW9mIHJhZGlpID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goW1wiUlJcIiwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKFtcIlJSXCIsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGlpXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQYXRoMkQ7XG59KCkpO1xuZnVuY3Rpb24gYnVpbGRQYXRoKGN0eCwgY29tbWFuZHMpIHtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuICAgIHZhciBlbmRBbmdsZTtcbiAgICB2YXIgc3RhcnRBbmdsZTtcbiAgICB2YXIgbGFyZ2VBcmNGbGFnO1xuICAgIHZhciBzd2VlcEZsYWc7XG4gICAgdmFyIGVuZFBvaW50O1xuICAgIHZhciBtaWRQb2ludDtcbiAgICB2YXIgYW5nbGU7XG4gICAgdmFyIGxhbWJkYTtcbiAgICB2YXIgdDE7XG4gICAgdmFyIHQyO1xuICAgIHZhciB4MTtcbiAgICB2YXIgeTE7XG4gICAgdmFyIHI7XG4gICAgdmFyIHJ4O1xuICAgIHZhciByeTtcbiAgICB2YXIgdztcbiAgICB2YXIgaDtcbiAgICB2YXIgcGF0aFR5cGU7XG4gICAgdmFyIGNlbnRlclBvaW50O1xuICAgIHZhciBjY3c7XG4gICAgdmFyIHJhZGlpO1xuICAgIHZhciBjcHggPSBudWxsO1xuICAgIHZhciBjcHkgPSBudWxsO1xuICAgIHZhciBxY3B4ID0gbnVsbDtcbiAgICB2YXIgcWNweSA9IG51bGw7XG4gICAgdmFyIHN0YXJ0UG9pbnQgPSBudWxsO1xuICAgIHZhciBjdXJyZW50UG9pbnQgPSBudWxsO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHBhdGhUeXBlID0gY29tbWFuZHNbaV1bMF07XG4gICAgICAgIC8vIFJlc2V0IGNvbnRyb2wgcG9pbnQgaWYgY29tbWFuZCBpcyBub3QgY3ViaWNcbiAgICAgICAgaWYgKHBhdGhUeXBlICE9PSBcIlNcIiAmJiBwYXRoVHlwZSAhPT0gXCJzXCIgJiYgcGF0aFR5cGUgIT09IFwiQ1wiICYmIHBhdGhUeXBlICE9PSBcImNcIikge1xuICAgICAgICAgICAgY3B4ID0gbnVsbDtcbiAgICAgICAgICAgIGNweSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGhUeXBlICE9PSBcIlRcIiAmJiBwYXRoVHlwZSAhPT0gXCJ0XCIgJiYgcGF0aFR5cGUgIT09IFwiUVwiICYmIHBhdGhUeXBlICE9PSBcInFcIikge1xuICAgICAgICAgICAgcWNweCA9IG51bGw7XG4gICAgICAgICAgICBxY3B5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYyA9IHZvaWQgMDtcbiAgICAgICAgc3dpdGNoIChwYXRoVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoVHlwZSA9PT0gXCJtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBjWzFdO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IGNbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ID0gY1sxXTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGNbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXRoVHlwZSA9PT0gXCJNXCIgfHwgIXN0YXJ0UG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQb2ludCA9IHsgeDogeCwgeTogeSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxcIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgeCArPSBjWzFdO1xuICAgICAgICAgICAgICAgIHkgKz0gY1syXTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgeCA9IGNbMV07XG4gICAgICAgICAgICAgICAgeSA9IGNbMl07XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJIXCI6XG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIHggPSBjWzFdO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICB4ICs9IGNbMV07XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIHkgPSBjWzFdO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICB5ICs9IGNbMV07XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICBjYXNlIFwiQVwiOlxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBvaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhUeXBlID09PSBcImFcIikge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IGNbNl07XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gY1s3XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjWzZdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gY1s3XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnggPSBjWzFdOyAvLyByeFxuICAgICAgICAgICAgICAgIHJ5ID0gY1syXTsgLy8gcnlcbiAgICAgICAgICAgICAgICBhbmdsZSA9IChjWzNdICogTWF0aC5QSSkgLyAxODA7XG4gICAgICAgICAgICAgICAgbGFyZ2VBcmNGbGFnID0gISFjWzRdO1xuICAgICAgICAgICAgICAgIHN3ZWVwRmxhZyA9ICEhY1s1XTtcbiAgICAgICAgICAgICAgICBlbmRQb2ludCA9IHsgeDogeCwgeTogeSB9O1xuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAgICAgICAgICAgbWlkUG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IChjdXJyZW50UG9pbnQueCAtIGVuZFBvaW50LngpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgeTogKGN1cnJlbnRQb2ludC55IC0gZW5kUG9pbnQueSkgLyAyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByb3RhdGVQb2ludChtaWRQb2ludCwgLWFuZ2xlKTtcbiAgICAgICAgICAgICAgICAvLyByYWRpdXMgY29ycmVjdGlvblxuICAgICAgICAgICAgICAgIGxhbWJkYSA9IChtaWRQb2ludC54ICogbWlkUG9pbnQueCkgLyAocnggKiByeCkgKyAobWlkUG9pbnQueSAqIG1pZFBvaW50LnkpIC8gKHJ5ICogcnkpO1xuICAgICAgICAgICAgICAgIGlmIChsYW1iZGEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhbWJkYSA9IE1hdGguc3FydChsYW1iZGEpO1xuICAgICAgICAgICAgICAgICAgICByeCAqPSBsYW1iZGE7XG4gICAgICAgICAgICAgICAgICAgIHJ5ICo9IGxhbWJkYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2VudGVyUG9pbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IChyeCAqIG1pZFBvaW50LnkpIC8gcnksXG4gICAgICAgICAgICAgICAgICAgIHk6IC0ocnkgKiBtaWRQb2ludC54KSAvIHJ4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0MSA9IHJ4ICogcnggKiByeSAqIHJ5O1xuICAgICAgICAgICAgICAgIHQyID0gcnggKiByeCAqIG1pZFBvaW50LnkgKiBtaWRQb2ludC55ICsgcnkgKiByeSAqIG1pZFBvaW50LnggKiBtaWRQb2ludC54O1xuICAgICAgICAgICAgICAgIGlmIChzd2VlcEZsYWcgIT09IGxhcmdlQXJjRmxhZykge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZVBvaW50KGNlbnRlclBvaW50LCBNYXRoLnNxcnQoKHQxIC0gdDIpIC8gdDIpIHx8IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVQb2ludChjZW50ZXJQb2ludCwgLU1hdGguc3FydCgodDEgLSB0MikgLyB0MikgfHwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKChtaWRQb2ludC55IC0gY2VudGVyUG9pbnQueSkgLyByeSwgKG1pZFBvaW50LnggLSBjZW50ZXJQb2ludC54KSAvIHJ4KTtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IE1hdGguYXRhbjIoLShtaWRQb2ludC55ICsgY2VudGVyUG9pbnQueSkgLyByeSwgLShtaWRQb2ludC54ICsgY2VudGVyUG9pbnQueCkgLyByeCk7XG4gICAgICAgICAgICAgICAgcm90YXRlUG9pbnQoY2VudGVyUG9pbnQsIGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVQb2ludChjZW50ZXJQb2ludCwgKGVuZFBvaW50LnggKyBjdXJyZW50UG9pbnQueCkgLyAyLCAoZW5kUG9pbnQueSArIGN1cnJlbnRQb2ludC55KSAvIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjZW50ZXJQb2ludC54LCBjZW50ZXJQb2ludC55KTtcbiAgICAgICAgICAgICAgICBjdHgucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUocngsIHJ5KTtcbiAgICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIDEsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhc3dlZXBGbGFnKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkNcIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgY3B4ID0gY1szXTsgLy8gTGFzdCBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgICAgY3B5ID0gY1s0XTtcbiAgICAgICAgICAgICAgICB4ID0gY1s1XTtcbiAgICAgICAgICAgICAgICB5ID0gY1s2XTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjWzFdLCBjWzJdLCBjcHgsIGNweSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjWzFdICsgeCwgY1syXSArIHksIGNbM10gKyB4LCBjWzRdICsgeSwgY1s1XSArIHgsIGNbNl0gKyB5KTtcbiAgICAgICAgICAgICAgICBjcHggPSBjWzNdICsgeDsgLy8gTGFzdCBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgICAgY3B5ID0gY1s0XSArIHk7XG4gICAgICAgICAgICAgICAgeCArPSBjWzVdO1xuICAgICAgICAgICAgICAgIHkgKz0gY1s2XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjcHggPT09IG51bGwgfHwgY3B5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNweCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGNweSA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKDIgKiB4IC0gY3B4LCAyICogeSAtIGNweSwgY1sxXSwgY1syXSwgY1szXSwgY1s0XSk7XG4gICAgICAgICAgICAgICAgY3B4ID0gY1sxXTsgLy8gbGFzdCBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgICAgY3B5ID0gY1syXTtcbiAgICAgICAgICAgICAgICB4ID0gY1szXTtcbiAgICAgICAgICAgICAgICB5ID0gY1s0XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjcHggPT09IG51bGwgfHwgY3B5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNweCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGNweSA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKDIgKiB4IC0gY3B4LCAyICogeSAtIGNweSwgY1sxXSArIHgsIGNbMl0gKyB5LCBjWzNdICsgeCwgY1s0XSArIHkpO1xuICAgICAgICAgICAgICAgIGNweCA9IGNbMV0gKyB4OyAvLyBsYXN0IGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgICBjcHkgPSBjWzJdICsgeTtcbiAgICAgICAgICAgICAgICB4ICs9IGNbM107XG4gICAgICAgICAgICAgICAgeSArPSBjWzRdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlFcIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgcWNweCA9IGNbMV07IC8vIGxhc3QgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgICAgIHFjcHkgPSBjWzJdO1xuICAgICAgICAgICAgICAgIHggPSBjWzNdO1xuICAgICAgICAgICAgICAgIHkgPSBjWzRdO1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHFjcHgsIHFjcHksIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgcWNweCA9IGNbMV0gKyB4OyAvLyBsYXN0IGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgICBxY3B5ID0gY1syXSArIHk7XG4gICAgICAgICAgICAgICAgeCArPSBjWzNdO1xuICAgICAgICAgICAgICAgIHkgKz0gY1s0XTtcbiAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhxY3B4LCBxY3B5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUXCI6XG4gICAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChxY3B4ID09PSBudWxsIHx8IHFjcHkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcWNweCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHFjcHkgPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxY3B4ID0gMiAqIHggLSBxY3B4OyAvLyBsYXN0IGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgICBxY3B5ID0gMiAqIHkgLSBxY3B5O1xuICAgICAgICAgICAgICAgIHggPSBjWzFdO1xuICAgICAgICAgICAgICAgIHkgPSBjWzJdO1xuICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHFjcHgsIHFjcHksIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHFjcHggPT09IG51bGwgfHwgcWNweSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBxY3B4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgcWNweSA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHFjcHggPSAyICogeCAtIHFjcHg7IC8vIGxhc3QgY29udHJvbCBwb2ludFxuICAgICAgICAgICAgICAgIHFjcHkgPSAyICogeSAtIHFjcHk7XG4gICAgICAgICAgICAgICAgeCArPSBjWzFdO1xuICAgICAgICAgICAgICAgIHkgKz0gY1syXTtcbiAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhxY3B4LCBxY3B5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ6XCI6XG4gICAgICAgICAgICBjYXNlIFwiWlwiOlxuICAgICAgICAgICAgICAgIGlmIChzdGFydFBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBzdGFydFBvaW50Lng7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBzdGFydFBvaW50Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBQ1wiOiAvLyBhcmNcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgeCA9IGNbMV07XG4gICAgICAgICAgICAgICAgeSA9IGNbMl07XG4gICAgICAgICAgICAgICAgciA9IGNbM107XG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSA9IGNbNF07XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBjWzVdO1xuICAgICAgICAgICAgICAgIGNjdyA9IGNbNl07XG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2N3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBVFwiOiAvLyBhcmNUb1xuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICB4MSA9IGNbMV07XG4gICAgICAgICAgICAgICAgeTEgPSBjWzJdO1xuICAgICAgICAgICAgICAgIHggPSBjWzNdO1xuICAgICAgICAgICAgICAgIHkgPSBjWzRdO1xuICAgICAgICAgICAgICAgIHIgPSBjWzVdO1xuICAgICAgICAgICAgICAgIGN0eC5hcmNUbyh4MSwgeTEsIHgsIHksIHIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkVcIjogLy8gZWxsaXBzZVxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICB4ID0gY1sxXTtcbiAgICAgICAgICAgICAgICB5ID0gY1syXTtcbiAgICAgICAgICAgICAgICByeCA9IGNbM107XG4gICAgICAgICAgICAgICAgcnkgPSBjWzRdO1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gY1s1XTtcbiAgICAgICAgICAgICAgICBzdGFydEFuZ2xlID0gY1s2XTtcbiAgICAgICAgICAgICAgICBlbmRBbmdsZSA9IGNbN107XG4gICAgICAgICAgICAgICAgY2N3ID0gY1s4XTtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKHJ4LCByeSk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCAxLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2N3KTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJcIjogLy8gcmVjdFxuICAgICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgICAgICB4ID0gY1sxXTtcbiAgICAgICAgICAgICAgICB5ID0gY1syXTtcbiAgICAgICAgICAgICAgICB3ID0gY1szXTtcbiAgICAgICAgICAgICAgICBoID0gY1s0XTtcbiAgICAgICAgICAgICAgICBzdGFydFBvaW50ID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUlJcIjogLy8gcm91bmRlZFJlY3RcbiAgICAgICAgICAgICAgICBjID0gY29tbWFuZHNbaV07XG4gICAgICAgICAgICAgICAgeCA9IGNbMV07XG4gICAgICAgICAgICAgICAgeSA9IGNbMl07XG4gICAgICAgICAgICAgICAgdyA9IGNbM107XG4gICAgICAgICAgICAgICAgaCA9IGNbNF07XG4gICAgICAgICAgICAgICAgcmFkaWkgPSBjWzVdO1xuICAgICAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSB7IHg6IHgsIHk6IHkgfTtcbiAgICAgICAgICAgICAgICBjdHgucm91bmRSZWN0KHgsIHksIHcsIGgsIHJhZGlpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRQb2ludCkge1xuICAgICAgICAgICAgY3VycmVudFBvaW50ID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQueCA9IHg7XG4gICAgICAgICAgICBjdXJyZW50UG9pbnQueSA9IHk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFBvbHlmaWxscyBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgc3Ryb2tlLCBmaWxsIGFuZCBpc1BvaW50SW5QYXRoIHNvIHRoYXQgdGhleSBzdXBwb3J0IFBhdGgyRCBvYmplY3RzLlxuICogQHBhcmFtIHtXaW5kb3dMaWtlfSB3aW5kb3cgLSB3aW5kb3cgbGlrZSBvYmplY3QgY29udGFpbmluZyBhIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBwb2x5ZmlsbFBhdGgyRCh3aW5kb3cpIHtcbiAgICBpZiAoIXdpbmRvdyB8fCAhd2luZG93LkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8fCB3aW5kb3cuUGF0aDJEKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IHdpbmRvdy5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kICovXG4gICAgLy8gc2V0dGluZyB1bmJvdW5kIGZ1bmN0aW9ucyBoZXJlLiBNYWtlIHN1cmUgdGhpcyBpcyBzZXQgaW4gZnVuY3Rpb24gY2FsbCBsYXRlclxuICAgIHZhciBjRmlsbCA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZmlsbDtcbiAgICB2YXIgY1N0cm9rZSA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuc3Ryb2tlO1xuICAgIHZhciBjSXNQb2ludEluUGF0aCA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuaXNQb2ludEluUGF0aDtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZCAqL1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBQYXRoMkQpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gYXJnc1swXTtcbiAgICAgICAgICAgIHZhciBmaWxsUnVsZSA9IGFyZ3NbMV0gfHwgXCJub256ZXJvXCI7XG4gICAgICAgICAgICBidWlsZFBhdGgodGhpcywgcGF0aC5jb21tYW5kcyk7XG4gICAgICAgICAgICBjRmlsbC5hcHBseSh0aGlzLCBbZmlsbFJ1bGVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmaWxsUnVsZSA9IGFyZ3NbMF0gfHwgXCJub256ZXJvXCI7XG4gICAgICAgICAgICByZXR1cm4gY0ZpbGwuYXBwbHkodGhpcywgW2ZpbGxSdWxlXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuc3Ryb2tlID0gZnVuY3Rpb24gc3Ryb2tlKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGJ1aWxkUGF0aCh0aGlzLCBwYXRoLmNvbW1hbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBjU3Ryb2tlLmFwcGx5KHRoaXMpO1xuICAgIH07XG4gICAgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5pc1BvaW50SW5QYXRoID0gZnVuY3Rpb24gaXNQb2ludEluUGF0aCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIFBhdGgyRCkge1xuICAgICAgICAgICAgLy8gZmlyc3QgYXJndW1lbnQgaXMgYSBQYXRoMkQgb2JqZWN0XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGFyZ3NbMF07XG4gICAgICAgICAgICB2YXIgeCA9IGFyZ3NbMV07XG4gICAgICAgICAgICB2YXIgeSA9IGFyZ3NbMl07XG4gICAgICAgICAgICB2YXIgZmlsbFJ1bGUgPSBhcmdzWzNdIHx8IFwibm9uemVyb1wiO1xuICAgICAgICAgICAgYnVpbGRQYXRoKHRoaXMsIHBhdGguY29tbWFuZHMpO1xuICAgICAgICAgICAgcmV0dXJuIGNJc1BvaW50SW5QYXRoLmFwcGx5KHRoaXMsIFt4LCB5LCBmaWxsUnVsZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNJc1BvaW50SW5QYXRoLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuUGF0aDJEID0gUGF0aDJEO1xufVxuXG5mdW5jdGlvbiByb3VuZFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaWkpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChyYWRpaSA9PT0gdm9pZCAwKSB7IHJhZGlpID0gMDsgfVxuICAgIGlmICh0eXBlb2YgcmFkaWkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJhZGlpID0gW3JhZGlpXTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIHJhbmdlIGVycm9yXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmFkaWkpKSB7XG4gICAgICAgIGlmIChyYWRpaS5sZW5ndGggPT09IDAgfHwgcmFkaWkubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAncm91bmRSZWN0JyBvbiAnXCIuY29uY2F0KHRoaXMuY29uc3RydWN0b3IubmFtZSwgXCInOiBcIikuY29uY2F0KHJhZGlpLmxlbmd0aCwgXCIgcmFkaWkgcHJvdmlkZWQuIEJldHdlZW4gb25lIGFuZCBmb3VyIHJhZGlpIGFyZSBuZWNlc3NhcnkuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByYWRpaS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdyb3VuZFJlY3QnIG9uICdcIi5jb25jYXQoX3RoaXMuY29uc3RydWN0b3IubmFtZSwgXCInOiBSYWRpdXMgdmFsdWUgXCIpLmNvbmNhdCh2LCBcIiBpcyBuZWdhdGl2ZS5cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJhZGlpLmxlbmd0aCA9PT0gMSAmJiByYWRpaVswXSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICAvLyBzZXQgdGhlIGNvcm5lcnNcbiAgICAvLyB0bCA9IHRvcCBsZWZ0IHJhZGl1c1xuICAgIC8vIHRyID0gdG9wIHJpZ2h0IHJhZGl1c1xuICAgIC8vIGJyID0gYm90dG9tIHJpZ2h0IHJhZGl1c1xuICAgIC8vIGJsID0gYm90dG9tIGxlZnQgcmFkaXVzXG4gICAgdmFyIG1pblJhZGl1cyA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC8gMjtcbiAgICB2YXIgdHIsIGJyLCBibDtcbiAgICB2YXIgdGwgPSAodHIgPSBiciA9IGJsID0gTWF0aC5taW4obWluUmFkaXVzLCByYWRpaVswXSkpO1xuICAgIGlmIChyYWRpaS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdHIgPSBibCA9IE1hdGgubWluKG1pblJhZGl1cywgcmFkaWlbMV0pO1xuICAgIH1cbiAgICBpZiAocmFkaWkubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHRyID0gYmwgPSBNYXRoLm1pbihtaW5SYWRpdXMsIHJhZGlpWzFdKTtcbiAgICAgICAgYnIgPSBNYXRoLm1pbihtaW5SYWRpdXMsIHJhZGlpWzJdKTtcbiAgICB9XG4gICAgaWYgKHJhZGlpLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB0ciA9IE1hdGgubWluKG1pblJhZGl1cywgcmFkaWlbMV0pO1xuICAgICAgICBiciA9IE1hdGgubWluKG1pblJhZGl1cywgcmFkaWlbMl0pO1xuICAgICAgICBibCA9IE1hdGgubWluKG1pblJhZGl1cywgcmFkaWlbM10pO1xuICAgIH1cbiAgICAvLyBiZWdpbiB3aXRoIGNsb3NpbmcgY3VycmVudCBwYXRoXG4gICAgLy8gdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAvLyBsZXQncyBkcmF3IHRoZSByb3VuZGVkIHJlY3RhbmdsZVxuICAgIHRoaXMubW92ZVRvKHgsIHkgKyBoZWlnaHQgLSBibCk7XG4gICAgdGhpcy5hcmNUbyh4LCB5LCB4ICsgdGwsIHksIHRsKTtcbiAgICB0aGlzLmFyY1RvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgdHIsIHRyKTtcbiAgICB0aGlzLmFyY1RvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYnIsIHkgKyBoZWlnaHQsIGJyKTtcbiAgICB0aGlzLmFyY1RvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBibCwgYmwpO1xuICAgIC8vIGFuZCBtb3ZlIHRvIHJlY3RzIGNvbnRyb2wgcG9pbnQgZm9yIGZ1cnRoZXIgcGF0aCBkcmF3aW5nXG4gICAgdGhpcy5tb3ZlVG8oeCwgeSk7XG59XG4vKipcbiAqIFBvbHlmaWxscyByb3VuZFJlY3Qgb24gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIGFuZCBQYXRoMkRcbiAqIEBwYXJhbSB7V2luZG93TGlrZX0gd2luZG93IC0gd2luZG93IGxpa2Ugb2JqZWN0IGNvbnRhaW5pbmcgYm90aCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgYW5kIFBhdGgyRCBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBwb2x5ZmlsbFJvdW5kUmVjdCh3aW5kb3cpIHtcbiAgICBpZiAoIXdpbmRvdyB8fCAhd2luZG93LkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSB3aW5kb3cuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBQYXRoMkQgPSB3aW5kb3cuUGF0aDJEO1xuICAgIC8vIHBvbHlmaWxsIHVuc3VwcG9ydGVkIHJvdW5kUmVjdCBmb3IgZS5nLiBmaXJlZm94IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvcm91bmRSZWN0I2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgIGlmIChDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgJiYgIUNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUucm91bmRSZWN0KSB7XG4gICAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUucm91bmRSZWN0ID0gcm91bmRSZWN0O1xuICAgIH1cbiAgICBpZiAoUGF0aDJEICYmICFQYXRoMkQucHJvdG90eXBlLnJvdW5kUmVjdCkge1xuICAgICAgICBQYXRoMkQucHJvdG90eXBlLnJvdW5kUmVjdCA9IHJvdW5kUmVjdDtcbiAgICB9XG59XG5cbmV4cG9ydHMuUGF0aDJEID0gUGF0aDJEO1xuZXhwb3J0cy5wYXJzZVBhdGggPSBwYXJzZVBhdGg7XG5leHBvcnRzLnBvbHlmaWxsUGF0aDJEID0gcG9seWZpbGxQYXRoMkQ7XG5leHBvcnRzLnBvbHlmaWxsUm91bmRSZWN0ID0gcG9seWZpbGxSb3VuZFJlY3Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/path2d-polyfill/dist/path2d-node.cjs\n");

/***/ })

};
;